<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "SS7_Stack_User_Guide.ent">
%BOOK_ENTITIES;
]>

<chapter
        id="configuring_jss7">
        <title>Configuring jboss-beans.xml</title>
<section id="configuring">
                <title>
                        Configuring &THIS.PLATFORM; SS7 Service
                </title>
                <para>Configuration is done through an XML descriptor file named <filename>jboss-beans.xml</filename> located at <filename>$JBOSS_HOME/server/profile_name/deploy/restcomm-ss7-service/META-INF</filename>, where
                <literal>profile_name</literal> is the name of the server profile.</para>

                <para>&THIS.PLATFORM; SS7 Layer 4 (<literal>SCCP, ISUP</literal>) leverages either of the following <literal>MTP</literal>
                layers to exchange signaling messages with remote signaling points:

                <itemizedlist>
                        <listitem>
                                <para><literal>M3UA</literal></para>
                        </listitem>
                        <listitem>
                                <para><literal>dahdi</literal></para>
                        </listitem>
                        <listitem>
                                <para><literal>dialogic</literal></para>
                        </listitem>
                </itemizedlist>
                </para>
                <section id="configuring_Rem_SGW">
                        <title>Configuring M3UA</title>
                        <para>
                    You must configure <literal>M3UAManagement</literal> if the underlying SS7 service will leverage <literal>M3UA</literal>. For more details on configuring <classname>M3UAManagement</classname>, please refer to <xref linkend="managing_m3ua" />.
            </para>

                <para>
                        Scroll down to the section for M3UA Layer in the <filename>jboss-beans.xml</filename> file and define the properties to suit your requirements.
                                <programlisting language="XML" role="XML"><![CDATA[
        <!-- ==================================================================== -->
        <!-- SCTP Properties                                                      -->
        <!-- Used by M3UA layer                                                   -->
        <!-- ==================================================================== -->
        <bean name="SCTPManagement" class="org.mobicents.protocols.sctp.ManagementImpl">
                <constructor>
                        <parameter>SCTPManagement</parameter>
                </constructor>
                <property name="persistDir">${jboss.server.data.dir}</property>
        </bean>

        <bean name="SCTPShellExecutor"
                class="org.restcomm.protocols.ss7.m3ua.impl.oam.SCTPShellExecutor">
                <property name="sctpManagement">
                        <inject bean="SCTPManagement" />
                </property>
        </bean>

        <!-- ==================================================================== -->
        <!-- M3UA -->
        <!-- M3UAManagement is managing the m3ua side commands -->
        <!-- ==================================================================== -->
        <!-- -->
        <!-- ==================================================================== -->
        <!-- M3UA -->
        <!-- M3UAManagement is managing the m3ua side commands -->
        <!-- ==================================================================== -->
        <!-- -->
        <bean name="Mtp3UserPart" class="org.restcomm.protocols.ss7.m3ua.impl.M3UAManagementImpl">
                <constructor>
                        <parameter>Mtp3UserPart</parameter>
                </constructor>
                <property name="persistDir">${jboss.server.data.dir}</property>
                <property name="transportManagement"><inject bean="SCTPManagement" /></property>
                <property name="routingLabelFormat"><inject bean="RoutingLabelFormat" /></property>
        </bean>

        <bean name="M3UAShellExecutor"
                class="org.restcomm.protocols.ss7.m3ua.impl.oam.M3UAShellExecutor">
                <property name="m3uaManagement">
                        <inject bean="Mtp3UserPart" />
                </property>
        </bean>]]>
                        </programlisting>
                </para>

  <formalpara>
                <title><classname>org.mobicents.protocols.sctp.ManagementImpl</classname></title>
                <para>This SCTP Management Bean takes a <classname>String</classname> as a constructor argument. The name is prepended to the name of the XML file created by the SCTP stack for persisting the state of SCTP resources. This XML file is stored in the path specified by the property <literal>persistDir</literal>. For example, in the above case, when &THIS.PLATFORM; SS7 Service is started, a file named <filename>SCTPManagement_sctp.xml</filename> will be created at <filename>$JBOSS_HOME/server/profile_name/data</filename> directory. The other properties of the Stack are defined below:
              </para>
  </formalpara>
  <formalpara>
        <title><classname>org.restcomm.protocols.ss7.m3ua.impl.M3UAManagementImpl</classname></title>
           <para>

This M3UA Management Bean takes a <classname>String</classname> as a constructor argument. The name is prepended to the name of the XML file created by the M3UA stack for persisting the state of M3UA resources. This XML file is stored in the path specified by the property <literal>persistDir</literal>. For example, in the above case, when &THIS.PLATFORM; SS7 Service is started, a file named <filename>Mtp3UserPart_m3ua.xml</filename> will be created at <filename>$JBOSS_HOME/server/profile_name/data</filename> directory. The other properties of the Stack are defined below:
        <variablelist>
                        <varlistentry>
                                <term>routingLabelFormat</term>
                                <listitem>
                                        <para>
                                                The routing label format supported by this network. See <xref linkend="configuring_routing_label_format"/> for further details.
                                        </para>
                                </listitem>
                        </varlistentry>
                </variablelist>
             </para>
  </formalpara>
            </section>
<section id="configuring_LinksetFactory">
                        <title>Configuring dahdi</title>
                        <para>
                        	<literal>Dahdi</literal> based MTP layer will only be used if you have installed <literal>dahdi</literal> based SS7 hardware (Sangoma or Diguim) cards.
                        	<literal>DahdiLinksetFactory</literal> is responsible for creating new instances of <literal>DahdiLinkset</literal> when instructed by
                        	the <literal>LinksetManager</literal>.
                        </para>

					<note>
		                <para>
		                	The corresponding native libraries for <literal>dahdi</literal> from folder
		                	<literal>restcomm-jss7-&lt;version&gt;/ss7/native/32</literal> or <literal>restcomm-jss7-&lt;version&gt;/ss7/native/64</literal> should be copied to
		                	 copied to <literal>$JBOSS_HOME/bin/META-INF/lib/linux2/x86</literal> if OS is 32 bit or <literal>$JBOSS_HOME/bin/META-INF/lib/linux2/x64</literal> if OS is 64 bit.
		                </para>
		                <para>
		                	libraries are compiled only for linux OS for now.
		                </para>
		                <para>
		                	<literal>restcomm-jss7-&lt;version&gt;/ss7/native/32</literal> and <literal>restcomm-jss7-&lt;version&gt;/ss7/native/64</literal> folders carries
		                	libraries compiled for 32 bit and 64 bit linux OS.
		                </para>
		                <para>
	                        <variablelist>
	                                <varlistentry>
	                                        <term>librestcomm-dahdi-linux</term>
	                                        <listitem>
	                                                <para>Native library for <literal>dahdi</literal> based cards - Diguim and Sangoma</para>
	                                        </listitem>
	                                </varlistentry>
	                                <varlistentry>
	                                        <term>libgctjni</term>
	                                        <listitem>
	                                                <para>Native library for Dialogic</para>
	                                        </listitem>
	                                </varlistentry>
	                        </variablelist>
		                </para>
                	</note>


                                        <programlisting language="XML" role="XML"><![CDATA[
        <bean name="DahdiLinksetFactory"
                class="org.restcomm.ss7.hardware.dahdi.oam.DahdiLinksetFactory">
        </bean>]]>
                        </programlisting>


                        <para> <literal>LinksetFactoryFactory</literal> is just a call-back class listening for new factories deployed. It maintains a Map of available 'factory name' vs 'factory'. You should never touch this bean.</para>


                        <para>
                                <literal>LinksetManager</literal> is responsible for managing <literal>Linkset</literal> and <literal>Link</literal>.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[<!-- ================================================ -->
    <!-- Linkset manager Service                                              -->
    <!-- ================================================ -->
        <bean name="LinksetFactoryFactory"
                class="org.restcomm.ss7.linkset.oam.LinksetFactoryFactory">
                <incallback method="addFactory" />
                <uncallback method="removeFactory" />
        </bean>

        <bean name="DahdiLinksetFactory"
                class="org.restcomm.ss7.hardware.dahdi.oam.DahdiLinksetFactory">
        </bean>

        <bean name="LinksetManager"
                class="org.restcomm.ss7.linkset.oam.LinksetManagerImpl">
                <constructor>
                                        <parameter>LinksetManager</parameter>
                                </constructor>
                                <property name="scheduler">
                                        <inject bean="SS7Scheduler" />
                                </property>
                <property name="linksetFactoryFactory">
                        <inject bean="LinksetFactoryFactory" />
                </property>
                <property name="persistDir">${jboss.server.data.dir}</property>
        </bean>

                <bean name="LinksetExecutor" class="org.restcomm.ss7.linkset.oam.LinksetExecutor">
                        <property name="linksetManager">
                                <inject bean="LinksetManager" />
                        </property>
                </bean>]]></programlisting>
                        <para>When LinksetManagerImpl is started it looks for the file  <filename>linksetmanager.xml</filename> containing serialized information about underlying linksets and links. The directory path is configurable by changing the value of the property <literal>persistDir</literal>.</para>
                        <warning><para><filename>linksetmanager.xml</filename> should never be edited by you manually. Always use the Shell Client to connect to the Stack and execute appropriate commands.</para></warning>
                        <para><literal>LinksetExecutor</literal> accepts the <literal>linkset</literal> commands and executes necessary operations.</para>

                </section>

                <section id="configuring_dialogic">
                        <title>Configuring dialogic</title>
                        <para>
                        	<literal>Dialogic</literal> based MTP layer will only be used if you have installed Dialogic cards.
                        	<literal>DialogicMtp3UserPart</literal> communicates with Dialogic hardware. It is assumed here that MTP3 and MTP2 is leveraged from
                        	the Dialogic Stack either on-board or on-host.
                        </para>

					<note>
		                <para>
		                	The corresponding native libraries for <literal>dialogic</literal> from folder
		                	<literal>restcomm-jss7-&lt;version&gt;/ss7/native/32</literal> or <literal>restcomm-jss7-&lt;version&gt;/ss7/native/64</literal> should be copied
		                	to <literal>$JBOSS_HOME/bin/META-INF/lib/linux2/x86</literal> if OS is 32 bit or copied to
		                	<literal>$JBOSS_HOME/bin/META-INF/lib/linux2/x64</literal> if OS is 64 bit.
		                </para>
		                <para>
		                	libraries are compiled only for linux OS for now.
		                </para>
		                <para>
		                	<literal>restcomm-jss7-&lt;version&gt;/ss7/native/32</literal> and <literal>restcomm-jss7-&lt;version&gt;/ss7/native/64</literal> folders carries
		                	libraries compiled for 32 bit and 64 bit linux OS.
		                </para>
		                <para>
	                        <variablelist>
	                                <varlistentry>
	                                        <term>libgctjni</term>
	                                        <listitem>
	                                                <para>Native library for Dialogic</para>
	                                        </listitem>
	                                </varlistentry>
	                                <varlistentry>
	                                        <term>librestcomm-dahdi-linux</term>
	                                        <listitem>
	                                                <para>Native library for <literal>dahdi</literal> based cards - Diguim and Sangoma</para>
	                                        </listitem>
	                                </varlistentry>
	                        </variablelist>
		                </para>
                	</note>


                                        <programlisting language="XML" role="XML"><![CDATA[
        <!-- ==================================================================== -->
        <!-- Dialogic Mtp3UserPart -->
        <!-- ==================================================================== -->
        <!---->
        <bean name="Mtp3UserPart" class="org.restcomm.ss7.hardware.dialogic.DialogicMtp3UserPart">
                <property name="sourceModuleId">61</property>
                <property name="destinationModuleId">34</property>
                <property name="routingLabelFormat">
                        <inject bean="RoutingLabelFormat" />
                </property>
        </bean>]]>
                        </programlisting>
                         <para>
The other properties of the Stack are defined below:
                <variablelist>
                        <varlistentry>
                                <term>sourceModuleId</term>
                                <listitem>
                                        <para>
                                                <literal>sourceModuleId</literal> is the id of source module and should match with the value configured in the file <filename>system.txt</filename> used by <literal>dialogic</literal> drivers. In the above example, 61 is assigned for restcomm process.
                                        </para>
                                </listitem>
                        </varlistentry>
                        <varlistentry>
                                <term>destinationModuleId</term>
                                <listitem>
                                        <para>
                                                <literal>destinationModuleId</literal> is the id of destination module. In the above example, 34 is the id of Dialogic MTP3 module.
                                        </para>
                                </listitem>
                        </varlistentry>
                        <varlistentry>
                                <term>routingLabelFormat</term>
                                <listitem>
                                        <para>
                                                The routing label format supported by this network. See <xref linkend="configuring_routing_label_format"/> for further details.
                                        </para>
                                </listitem>
                        </varlistentry>
                </variablelist>
             </para>
                </section>

        <section id="configuring_routing_label_format">
                <title>Configuring MTP3 routing label</title>
                <para>
                        MTP Level 3 routes messages based on the routing label in the signaling information field (SIF) of
                                message signal units. The routing label is comprised of the destination point code (DPC),
                                originating point code (OPC), and signaling link selection (SLS) field. Overtime different standards
                                cameup with different routing label format. For example An ANSI routing label uses 7 octets; an ITU-T routing label uses 4 octets.
                </para>
                <para>
                        &THIS.PLATFORM; &THIS.APPLICATION; is flexible to configure the routing label as shown below.
                </para>
                                        <programlisting language="XML" role="XML"><![CDATA[
        <!-- ==================================================================== -->
        <!-- MTP3 Properties -->
        <!-- Define MTP3 routing label Format -->
        <!-- ==================================================================== -->
        <bean name="RoutingLabelFormat" class="org.restcomm.protocols.ss7.mtp.RoutingLabelFormat">
                <constructor factoryClass="org.restcomm.protocols.ss7.mtp.RoutingLabelFormat"
                        factoryMethod="getInstance">
                        <parameter>ITU</parameter>
                </constructor>
        </bean>]]>
                        </programlisting>
                        <para>
                                Following table shows various routing formats supported
                        </para>
                                <table frame="all" pgwide="1">
                                        <title>Routing Format</title>
                                        <tgroup colsep="1" cols="3">
                                                <colspec colnum="1" colname="c0" colwidth="3*" />
                                                <colspec colnum="2" colname="c3" colwidth="3*" />
                                                <colspec colnum="3" colname="c6" colwidth="3*" />
                                                <thead>
                                                        <row>
                                                                <entry>Name</entry>
                                                                <entry>point code length</entry>
                                                                <entry>sls length</entry>
                                                        </row>
                                                </thead>
                                                <tbody>
                                                        <row>
                                                                <entry>ITU</entry>
                                                                <entry>14-bits</entry>
                                                                <entry>4-bits</entry>
                                                        </row>
                                                        <row>
                                                                <entry>ANSI_Sls8Bit</entry>
                                                                <entry>24-bits</entry>
                                                                <entry>8-bits</entry>
                                                        </row>
                                                        <row>
                                                                <entry>ANSI_Sls5Bit</entry>
                                                                <entry>24-bits</entry>
                                                                <entry>5-bits</entry>
                                                        </row>
                                                </tbody>
                                        </tgroup>
                                </table>
        </section>

                <section id="configuring_SCCP">
                        <title>Configuring SCCP</title>
                        <para>
                                As name suggests <literal>SccpStack</literal> initiates the SCCP stack routines.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[     <!-- ==================================================================== -->
        <!-- SCCP Service -->
        <!-- ==================================================================== -->

        <!--<bean name="RuleComparator" class="org.restcomm.protocols.ss7.sccp.impl.router.RuleByIdComparator"/>-->
        <bean name="RuleComparator" class="org.restcomm.protocols.ss7.sccp.impl.router.RuleComparator"/>
        <bean name="RuleComparatorFactory" class="org.restcomm.protocols.ss7.sccp.impl.router.RuleComparatorFactory">
            <constructor factoryClass="org.restcomm.protocols.ss7.sccp.impl.router.RuleComparatorFactory"
        				   factoryMethod="getInstance">
            <parameter>RuleComparatorFactory</parameter>
            </constructor>
            <property name="ruleComparator">
        	      <inject bean="RuleComparator"/>
            </property>
        </bean>

        <bean name="SccpStack" class="org.restcomm.protocols.ss7.sccp.impl.SccpStackImpl">
                <constructor>
                        <parameter>
                            <inject bean="SS7Scheduler" />
                        </parameter>
                        <parameter>SccpStack</parameter>
                </constructor>
                <property name="persistDir">${jboss.server.data.dir}</property>
                <property name="mtp3UserParts">
                        <map keyClass="java.lang.Integer" valueClass="org.restcomm.protocols.ss7.mtp.Mtp3UserPart">
                                <entry>
                                        <key>1</key>
                                        <value>
                                                <inject bean="Mtp3UserPart" />
                                        </value>
                                </entry>
                        </map>
                </property>
        </bean>

        <bean name="SccpExecutor"
                class="org.restcomm.protocols.ss7.sccp.impl.oam.SccpExecutor">
                <property name="sccpStack">
                        <inject bean="SccpStack" />
                </property>
        </bean>]]></programlisting>
                        <para>
                                <classname>org.restcomm.protocols.ss7.sccp.impl.SccpStackImpl</classname> takes <classname>String</classname> as constructor
                                argument. The name is prepend to <literal>xml</literal> file created by SCCP stack for persisting state of SCCP resources.
                                The <literal>xml</literal> is stored in path specified by <literal>persistDir</literal> property above.
                        </para>
                        <para>
                                For example in above case, when &THIS.PLATFORM; SS7 Service is started two file's <filename>SccpStack_sccpresource.xml</filename>
                                and <filename>SccpStack_sccprouter.xml</filename> will be created at <filename>$JBOSS_HOME/server/profile_name/data</filename> directory
                        </para>
                        <para>
                                Stack has following properties:
                                <variablelist>
                                        <varlistentry>
                                                <term>persistDir</term>
                                                <listitem>
                                                        <para>As explained above</para>
                                                </listitem>
                                        </varlistentry>
                                        <varlistentry>
                                                <term>mtp3UserParts</term>
                                                <listitem>
                                                        <para>specifies SS7 Level 3 to be used as transport medium(  be it SS7 card or M3UA). &THIS.PLATFORM; &THIS.APPLICATION; SCCP allows configuring multiple MTP3 layers for
                                                        same SCCP stack. This allows to have multiple local point-code and connecting to various networks while SCCP layer remains same </para>
                                                </listitem>
                                        </varlistentry>
                                </variablelist>
                        </para>

                        <para> <literal>SccpExecutor</literal> accepts <literal>sccp</literal> commands and executes necessary operations</para>
                        <para> For sorting SCCP rules by ID we need to set  <literal>RuleComparator</literal> to <literal>org.restcomm.protocols.ss7.sccp.impl.router.RuleByIdComparator</literal>. By default it sorts by calledDigits and callingDigits patterns.</para>
                </section>

                <section id="configuring_TCAP">
                        <title>Configuring TCAP</title>
                        <para>
                                <literal>TcapStack</literal> initiates the TCAP stack routines. Respective TCAP stack beans are instantiated for each <literal>MAP</literal>, <literal>CAP</literal>
                                Service. If you are using either one, feel free to delete the other.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[
        <!-- ==================================================================== -->
        <!-- TCAP Service -->
        <!-- ==================================================================== -->
        <bean name="TcapStackMap" class="org.restcomm.protocols.ss7.tcap.TCAPStackImpl">
                <constructor>
                        <parameter>
                                <inject bean="SccpStack" property="sccpProvider" />
                        </parameter>
                        <parameter>8</parameter>
                </constructor>
                <property name="dialogIdleTimeout">60000</property>
                <property name="invokeTimeout">30000</property>
                <property name="maxDialogs">25000</property>
        </bean>

        <bean name="TcapStackCap" class="org.restcomm.protocols.ss7.tcap.TCAPStackImpl">
                <constructor>
                        <parameter>
                                <inject bean="SccpStack" property="sccpProvider" />
                        </parameter>
                        <parameter>146</parameter>
                </constructor>
                <property name="dialogIdleTimeout">60000</property>
                <property name="invokeTimeout">30000</property>
                <property name="maxDialogs">25000</property>
        </bean>

        <bean name="TcapStack" class="org.restcomm.protocols.ss7.tcap.TCAPStackImpl">
                <constructor>
                        <parameter>
                                <inject bean="SccpStack" property="sccpProvider" />
                        </parameter>
                        <parameter>9</parameter>
                </constructor>
                <property name="dialogIdleTimeout">60000</property>
                <property name="invokeTimeout">30000</property>
                <property name="maxDialogs">25000</property>
        </bean>

		<bean name="TcapExecutor" class="org.restcomm.protocols.ss7.tcap.oam.TCAPExecutor">
			<property name="tcapStacks">
				<map keyClass="java.lang.String" valueClass="org.restcomm.protocols.ss7.tcap.TCAPStackImpl">
					<entry>
						<key>TcapStackMap</key>
						<value>
							<inject bean="TcapStackMap" />
						</value>
					</entry>
					<entry>
						<key>TcapStackCap</key>
						<value>
							<inject bean="TcapStackCap" />
						</value>
					</entry>
					<entry>
						<key>TcapStack</key>
						<value>
							<inject bean="TcapStack" />
						</value>
					</entry>
				</map>
			</property>
		</bean>]]></programlisting>
                        <para>
                                <classname>org.restcomm.protocols.ss7.tcap.TCAPStackImpl</classname> takes <classname>SccpStack</classname> as constructor
                                argument. TCAP uses passed SCCP stack. Constructor also takes the sub system number (SSN) which is registered with passed SCCP stack.
                        </para>

                        <para>
                                TCAP Stack has following configurable properties:
                                <variablelist>
                                        <varlistentry>
                                                <term>dialogIdleTimeout: public void setDialogIdleTimeout(long l);</term>
                                                <listitem>
                                                        <para>This property specifies how long a dialog can be idle (i.e. not receive/send any messages) before a timeout occurs. The value is specified in milliseconds. When a timeout occurs the method <literal>TCListener.onDialogTimeout()</literal> will be invoked. If a TCAP-User does not invoke <literal>Dialog.keepAlive()</literal> inside the method <literal>TCListener.onDialogTimeout()</literal>, the TCAP Dialog will be released.</para>
                                                </listitem>
                                        </varlistentry>
                                        <varlistentry>
                                                <term>invokeTimeout: public void setInvokeTimeout(long l);</term>
                                                <listitem>
                                                        <para>This property specifies, by default, how long Invoke will wait for a response from a peer before a timeout occurs. The value is specified in milliseconds. If a TCAP-User does not specify a custom Invoke timeout when sending a new Invoke, this default value will be used for outgoing Invoke timeout. When this timeout occurs <literal>TCListener.onInvokeTimeout()</literal> will be invoked.
                                                        </para>
                                                </listitem>
                                        </varlistentry>
                                        <varlistentry>
                                                <term>maxDialogs: public void setMaxDialogs(int v); </term>
                                                <listitem>
                                                        <para>
This property specifes the maximum number of concurrent dialogs allowed to be alive at any point of time. If this property is not set, a default value of 5000 dialogs will be used. If an application attempts to create more dialogs than this maximum number specified, an Exception is thrown.
                                                        </para>
                                                </listitem>
                                        </varlistentry>


                                        <varlistentry>
                                                <term>dialogIdRangeStart: public void setDialogIdRangeStart(long val);</term>
                                                <listitem>
                                                        <para>
TCAP stack can be configured to use a range of local DialogId values. You may install a set of TCAP Stack instances with different DialogId ranges. These ranges can be used for loadsharing of SS7 traffic between the TCAP instances.
All the outgoing Dialogs will have id starting with <literal>dialogIdRangeStart</literal>. This value of <literal>dialogIdRangeStart</literal> cannt be greater than <literal>dialogIdRangeEnd</literal>. In addition, the value of <literal>dialogIdRangeEnd - dialogIdRangeStart</literal> must always be less than the value of <literal>maxDialogs</literal>. </para>
                                                </listitem>
                                        </varlistentry>
                                        <varlistentry>
                                                <term>dialogIdRangeEnd: public void setDialogIdRangeStart(long val);</term>
                                                <listitem>
                                                        <para>
                                                                All the outgoing Dialogs will have id starting with <literal>dialogIdRangeStart</literal> and incremented by 1 for each new outgoing dialog till <literal>dialogIdRangeEnd</literal>. After this,
                                                                dialog will again start from the value of<literal>dialogIdRangeStart</literal>.
                                                        </para>
                                                </listitem>
                                       </varlistentry>
                                        <varlistentry>
                                                <term>previewMode: public void setPreviewMode(boolean val);</term>
                                                <listitem>
                                                        <para>
                                                                PreviewMode is needed for special processing mode. By default TCAP is not set in PreviewMode. When PreviewMode set in TCAP level:
<itemizedlist>
        <listitem>
                <para>Stack only listens for incoming messages and does not send anything. The methods <literal>send()</literal>,
  <literal>close()</literal>, <literal>sendComponent()</literal> and other such methods do nothing.</para>
        </listitem>
        <listitem>
                <para>A TCAP Dialog is temporary. TCAP Dialog is discarded after any
   incoming message like TC-BEGIN or TC-CONTINUE has been processed.</para>
        </listitem>
        <listitem>
                <para>For any incoming messages (including TC-CONTINUE, TC-END, TC-ABORT)
   a new TCAP Dialog is created (and then deleted).</para>
        </listitem>
        <listitem>
                <para>There are no timers and timeouts.</para>
        </listitem>
</itemizedlist>
                                                        </para>
                                                </listitem>
                                       </varlistentry>
                                </variablelist>
                        </para>

						<para> <literal>TcapExecutor</literal> accepts <literal>tcap</literal> commands and executes necessary operations</para>

                </section>
                    <section id="configuring_ShellExecutor">
                        <title>Configuring ShellExecutor</title>
                        <para>
                                <literal>ShellExecutor</literal> is responsible for listening incoming commands. Received commands are executed on local resources to
                                perform actions like creation and management of <literal>TCAP</literal>, <literal>SCCP</literal>, <literal>SCTP</literal> and
                               	<literal>M3UA</literal> stack.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[     <!-- ==================================================================== -->
        <!-- Shell Service -->
        <!-- ==================================================================== -->
        <!-- Define Shell Executor -->
	<bean name="ShellExecutor" class="org.restcomm.ss7.management.console.ShellServer">
		<constructor>
			<parameter>
				<inject bean="SS7Scheduler" />
			</parameter>
			<parameter>
				<list class="javolution.util.FastList"
					elementClass="org.restcomm.ss7.management.console.ShellExecutor">
					<inject bean="SccpExecutor" />
					<inject bean="M3UAShellExecutor" />
					<inject bean="SCTPShellExecutor" />
					<inject bean="TcapExecutor" />
					<!-- <inject bean="LinksetExecutor" /> -->
				</list>
			</parameter>
		</constructor>

		<property name="address">${jboss.bind.address}</property>
		<property name="port">3435</property>
		<property name="securityDomain">java:/jaas/jmx-console</property>
	</bean>]]></programlisting>
                        <para>By default ShellExecutor listens at <literal>jboss.bind.address</literal> and port <literal>3435</literal>.
                        You may set the <literal>address</literal> property to any valid IP address that your host is assigned.
                        The shell commands are exchanged over TCP/IP.</para>
                        <note><para>To understand JBoss bind options look at
                        <ulink url="http://docs.jboss.org/jbossas/docs/Installation_And_Getting_Started_Guide/5/html_single/index.html">Installation_And_Getting_Started_Guide</ulink> </para> </note>

                        <para>
                                <literal>SCTPShellExecutor</literal> and <literal>M3UAShellExecutor</literal> is declared only if MTP layer <literal>M3UA</literal> is used. If <literal>dialogic</literal>
                                MTP layer is used these beans are not decalred and should be removed from <classname>FastList</classname> too. For <literal>dahdi</literal> need to declare <literal>LinksetExecutor</literal>
                                bean and add in <classname>FastList</classname> above.
                        </para>

                </section>
                <section id="configuring_MAP">
                        <title>Configuring MAP</title>
                        <para>
                                <literal>MapStack</literal> initiates the MAP stack routines.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[<!-- ==================================================================== -->
        <!-- MAP Service -->
        <!-- ==================================================================== -->
        <bean name="MapStack" class="org.restcomm.protocols.ss7.map.MAPStackImpl">
                <constructor>
                        <parameter>
                                <inject bean="TcapStackMap" property="provider" />
                        </parameter>
                </constructor>
        </bean>]]></programlisting>
                         <para>
                                <classname>org.restcomm.protocols.ss7.map.MAPStackImpl</classname> takes <classname>TcapStack</classname> as constructor
                                argument. MAP uses passed TCAP stack.
                        </para>
                         <para>
                                Feel free to delete declaration of this bean if your service is consuming only CAP messages.
                        </para>
                </section>

                <section id="configuring_CAP">
                        <title>Configuring CAP</title>
                        <para>
                                <literal>CapStack</literal> initiates the CAP stack routines.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[     <!-- ==================================================================== -->
        <!-- CAP Service -->
        <!-- ==================================================================== -->
        <bean name="CapStack" class="org.restcomm.protocols.ss7.cap.CAPStackImpl">
                <constructor>
                        <parameter>
                                <inject bean="TcapStackCap" property="provider" />
                        </parameter>
                </constructor>
        </bean>]]></programlisting>
                         <para>
                                <classname>org.restcomm.protocols.ss7.cap.CAPStackImpl</classname> takes <classname>TcapStack</classname> as constructor
                                argument. CAP uses passed TCAP stack.
                        </para>
                        <para>
                                Feel free to delete declaration of this bean if your service is consuming only MAP messages.
                        </para>
                </section>

                 <section id="configuring_ISUP">
                        <title>Configuring ISUP</title>
                        <para>
                                <literal>IsupStack</literal> initiates the ISUP stack routines.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[     <!-- ==================================================================== -->
        <!-- ISUP Service -->
        <!-- ==================================================================== -->
        <bean name="CircuitManager"
                class="org.restcomm.protocols.ss7.isup.impl.CircuitManagerImpl">
        </bean>

        <bean name="IsupStack" class="org.restcomm.protocols.ss7.isup.impl.ISUPStackImpl">
                <constructor>
                        <parameter>
                                <inject bean="SS7Scheduler" />
                        </parameter>
                        <parameter>22234</parameter>
                        <parameter>2</parameter>
                </constructor>
                <property name="mtp3UserPart">
                        <inject bean="Mtp3UserPart" />
                </property>
                <property name="circuitManager">
                        <inject bean="CircuitManager" />
                </property>
        </bean>]]></programlisting>
                         <para>
                                <classname>org.restcomm.protocols.ss7.isup.impl.ISUPStackImpl</classname> takes <classname>SS7Scheduler</classname>, local signaling pointcode and network indicator
                                 as constructor argument. MAP uses passed TCAP stack.
                        </para>


                        <para>
                                Stack has following properties:
                                <variablelist>
                                        <varlistentry>
                                                <term>mtp3UserPart</term>
                                                <listitem>
                                                        <para>specifies SS7 Level 3 to be used as transport medium( be it SS7 card or M3UA). </para>
                                                </listitem>
                                        </varlistentry>
                                        <varlistentry>
                                                <term>circuitManager</term>
                                                <listitem>
                                                        <para>
                                                               CIC management bean
                                                        </para>
                                                </listitem>
                                        </varlistentry>
                                </variablelist>
                        </para>

                         <para>
                                Feel free to delete declaration of this bean if your service is not consuming ISUP messages.
                        </para>
                </section>

              <section id="configuring_SS7Service">
                        <title>Configuring SS7Service</title>
                        <para>
                                SS7Service acts as core engine binding all the components together.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[<!-- ==================================================================== -->
        <!-- Restcomm SS7 Service -->
        <!-- ==================================================================== -->
        <bean name="TCAPSS7Service" class="org.restcomm.ss7.SS7Service">
                <constructor><parameter>TCAP</parameter></constructor>
                <annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="org.restcomm.ss7:service=TCAPSS7Service",exposedInterface=org.restcomm.ss7.SS7ServiceMBean.class,registerDirectly=true)
                </annotation>
                <property name="jndiName">java:/restcomm/ss7/tcap</property>
                <property name="stack">
                        <inject bean="TcapStack" property="provider" />
                </property>
        </bean>
        <bean name="MAPSS7Service" class="org.restcomm.ss7.SS7Service">
                <constructor><parameter>MAP</parameter></constructor>
                <annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="org.restcomm.ss7:service=MAPSS7Service",exposedInterface=org.restcomm.ss7.SS7ServiceMBean.class,registerDirectly=true)
                </annotation>
                <property name="jndiName">java:/restcomm/ss7/map</property>
                <property name="stack">
                        <inject bean="MapStack" property="MAPProvider" />
                </property>
        </bean>
        <bean name="CAPSS7Service" class="org.restcomm.ss7.SS7Service">
                <constructor><parameter>CAP</parameter></constructor>
                <annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="org.restcomm.ss7:service=CAPSS7Service",exposedInterface=org.restcomm.ss7.SS7ServiceMBean.class,registerDirectly=true)
                </annotation>
                <property name="jndiName">java:/restcomm/ss7/cap</property>
                <property name="stack">
                        <inject bean="CapStack" property="CAPProvider" />
                </property>
        </bean>
        <bean name="ISUPSS7Service" class="org.restcomm.ss7.SS7Service">
                <constructor><parameter>ISUP</parameter></constructor>
                <annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="org.restcomm.ss7:service=ISUPSS7Service",exposedInterface=org.restcomm.ss7.SS7ServiceMBean.class,registerDirectly=true)
                </annotation>
                <property name="jndiName">java:/restcomm/ss7/isup</property>
                <property name="stack">
                        <inject bean="IsupStack" property="isupProvider" />
                </property>
        </bean>]]></programlisting>
                                                <para> TCAPSS7Service binds TcapStack to JNDI <literal>java:/restcomm/ss7/tcap</literal>. </para>
                        <para> MAPSS7Service binds MapStack to JNDI <literal>java:/restcomm/ss7/map</literal>. </para>
                        <para> CAPSS7Service binds CapStack to JNDI <literal>java:/restcomm/ss7/cap</literal>. </para>
                          <para> ISUPSS7Service binds IsupStack to JNDI <literal>java:/restcomm/ss7/isup</literal>. </para>
                        <para>The JNDI name can be configured to any valid JNDI name specific to your application.</para>
                        <para>Feel free to delete service that your application is not using.</para>
                </section>
        </section>
<section id="configuring_sgw">
                <title>
                        Configuring &THIS.PLATFORM; Signaling Gateway
                </title>
                <para>Configuration is done through an XML descriptor named <filename>sgw-beans.xml</filename> and is
                located at <filename>restcomm-ss7-sgw/deploy</filename> </para>

                <note>
	                <para>
	                	Before &THIS.PLATFORM; Signaling Gateway is configured the corresponding native libraries for <literal>dahdi</literal> or <literal>dialogic</literal> from folder
	                	<literal>restcomm-ss7-sgw/native/32</literal> or <literal>restcomm-ss7-sgw/native/64</literal> should be copied to <literal>restcomm-ss7-sgw/native</literal>.
	                </para>
	                <para>
	                	<literal>32</literal> and <literal>64</literal> folders carries libraries compiled for 32 bit and 64 bit. Depending on which JDK (32 or 64 bit) is used to start
	                	Signaling Gateway, corresponding library should be coppied.
	                </para>
	                <para>
                        <variablelist>
                                <varlistentry>
                                        <term>libgctjni</term>
                                        <listitem>
                                                <para>Native library for Dialogic</para>
                                        </listitem>
                                </varlistentry>
                                <varlistentry>
                                        <term>librestcomm-dahdi-linux</term>
                                        <listitem>
                                                <para>Native library for <literal>dahdi</literal> based cards - Diguim and Sangoma</para>
                                        </listitem>
                                </varlistentry>
                        </variablelist>
	                </para>
                </note>
                <section id="configuring_SGWP">
                        <title>Configuring M3AU (Signaling Gateway)</title>
                        <para>
                                SGW will expose the SS7 signals received from legacy network to IP network over M3AU
                        </para>

                                        <programlisting language="XML" role="XML"><![CDATA[
        <bean name="SCTPManagement" class="org.mobicents.protocols.sctp.ManagementImpl">
                <constructor>
                        <parameter>SCTPManagement</parameter>
                </constructor>
                <property name="persistDir">${sgw.home.dir}/ss7</property>
        </bean>

        <bean name="SCTPShellExecutor"
                class="org.restcomm.protocols.ss7.m3ua.impl.oam.SCTPShellExecutor">
                <property name="sctpManagement">
                        <inject bean="SCTPManagement" />
                </property>
        </bean>

        <bean name="Mtp3UserPart" class="org.restcomm.protocols.ss7.m3ua.impl.M3UAManagement">
                <constructor>
                        <parameter>Mtp3UserPart</parameter>
                </constructor>
                <property name="persistDir">${sgw.home.dir}/ss7</property>
                <property name="transportManagement">
                        <inject bean="SCTPManagement" />
                </property>
        </bean>

        <bean name="M3UAShellExecutor"
                class="org.restcomm.protocols.ss7.m3ua.impl.oam.M3UAShellExecutor">
                <property name="m3uaManagement">
                        <inject bean="Mtp3UserPart" />
                </property>
        </bean>]]>
                        </programlisting>
                </section>

                <section id="sgw_configuring_LinksetFactory">
                        <title>Configuring LinksetFactory</title>
                        <para> Concrete implementation of <literal>LinksetFactory</literal> is responsible to create
                        new instances of corresponding <literal>Linkset</literal> when instructed by <literal>LinksetManager</literal>.
                        &THIS.PLATFORM; Signaling Gateway defines two linkset factories : </para>

                        <itemizedlist>
                                <listitem>
                                        <para><literal>DahdiLinksetFactory</literal> </para>
                                        <programlisting language="XML" role="XML"><![CDATA[
        <bean name="DahdiLinksetFactory"
                class="org.restcomm.ss7.hardware.dahdi.oam.DahdiLinksetFactory">
        </bean>]]>
                        </programlisting>
                                </listitem>
                                <listitem>
                                        <para><literal>DialogicLinksetFactory</literal></para>
                                         <programlisting language="XML" role="XML"><![CDATA[
        <bean name="DialogicLinksetFactory"
                class="org.restcomm.ss7.hardware.dialogic.oam.DialogicLinksetFactory">
        </bean>]]>
                        </programlisting>
                                </listitem>
                        </itemizedlist>
                        <para>Its highly unlikely that you would require both the factories on same gateway. If you have <literal>dahdi</literal> based
                        SS7 card installed, keep <literal>DahdiLinksetFactory</literal> and remove other. If you have <literal>dialogic</literal> based
                        SS7 card installed, keep <literal>DialogicLinksetFactory</literal> and remove other.
                        </para>
                        <para> <literal>LinksetFactoryFactory</literal> is just a call-back class listening for new factories deployed
                        and maintains Map of available factory name vs factory. You should never touch this bean.</para>
                </section>
                <section id="sgw_configuring_LinksetManager">
                        <title>Configuring LinksetManager</title>
                        <para>
                                <literal>LinksetManager</literal> is responsible for managing <literal>Linkset</literal> and <literal>Link</literal>.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[<!-- ================================================ -->
    <!-- Linkset manager Service                                              -->
    <!-- ================================================ -->
        <bean name="LinksetManager" class="org.restcomm.ss7.linkset.oam.LinksetManagerImpl">
                <constructor>
                        <parameter>LinksetManager</parameter>
                </constructor>
                <property name="scheduler">
                        <inject bean="Scheduler" />
                </property>

                <property name="linksetFactoryFactory">
                        <inject bean="LinksetFactoryFactory" />
                </property>
                <property name="persistDir">${sgw.home.dir}/ss7</property>
        </bean>

        <bean name="LinksetExecutor"
                class="org.restcomm.ss7.linkset.oam.LinksetExecutor">
                <property name="linksetManager">
                        <inject bean="LinksetManager" />
                </property>
        </bean>]]></programlisting>
                        <para>LinksetManagerImpl when started looks for file  <filename>linksetmanager.xml</filename> containing serialized information about
                        underlying linksets and links. The directory path is configurable by changing value of <literal>persistDir</literal> property.</para>
                        <warning><para><filename>linksetmanager.xml</filename> should never be edited by hand. Always use Shell Client to connect to
                        &THIS.PLATFORM; Signaling Gateway and execute commands.</para></warning>
                        <para><literal>LinksetExecutor</literal> accepts the <literal>linkset</literal> commands and executes necessary operations.</para>
                </section>

                <section id="sgw_configuring_ShellExecutor">
                        <title>Configuring ShellExecutor</title>
                        <para>
                                <literal>ShellExecutor</literal> is responsible for listening to incoming command. Received commands are executed on local resources to
                                perform actions like creation and management of <literal>Linkset</literal>,
                                management of <literal>M3UA</literal> stack.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[<!-- ================================================ -->
    <!-- Shell Service                                                        -->
    <!-- ================================================ -->
        <bean name="ShellExecutor" class="org.restcomm.ss7.management.console.ShellServer">
                <constructor>
                        <parameter>
                                <inject bean="Scheduler" />
                        </parameter>
                        <parameter>
                                <list class="javolution.util.FastList" elementClass="org.restcomm.ss7.management.console.ShellExecutor">
                                        <inject bean="M3UAShellExecutor" />
                                        <inject bean="SCTPShellExecutor" />
                                        <inject bean="LinksetExecutor" />
                                </list>
                        </parameter>
                </constructor>

                <property name="address">${sgw.bind.address}</property>
                <property name="port">3435</property>
        </bean>]]></programlisting>
                        <para>By default ShellExecutor listens at <literal>sgw.bind.address</literal> and port <literal>3436</literal>.
                        You may set the <literal>address</literal> property to any valid IP address that your host is assigned.
                        The shell commands are exchanged over TCP/IP.</para>
                </section>

                <section id="sgw_configuring_SGW">
                        <title>Configuring SignalingGateway</title>
                        <para>
                                <literal>SignalingGateway</literal> acts as core engine binding all the components together.
                        </para>
                        <programlisting language="XML" role="XML"><![CDATA[        <!-- ================================================ -->
    <!-- restcomm Signaling Gateway                                      -->
    <!-- ================================================ -->
        <bean name="SignalingGateway"
                class="org.restcomm.ss7.sgw.SignalingGateway">

                <property name="shellExecutor">
                        <inject bean="ShellExecutor" />
                </property>

                <property name="nodalInterworkingFunction">
                        <inject bean="NodalInterworkingFunction" />
                </property>

        </bean>]]></programlisting>
                        <para>The <literal>NodalInterworkingFunction</literal> sits between the SS7 netwrok and IP network and routes messages
                        to/from both the MTP3 and the M3UA layer, based on the SS7 DPC or DPC/SI address information</para>
                </section>
        </section>
</chapter>
